<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part 2: Spec-Driven Development - GASD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Outfit:wght@600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../style.css">
</head>

<body>
    <main>
        <nav class="breadcrumb">
            <a href="../../index.html">Home</a> <span>/</span> <a href="Intro.html">Stop Vibe Coding</a> <span>/</span>
            <span>Part 2</span>
        </nav>

        <header>
            <div class="logo-container">
                <img src="../../logo_files/gasd_icon_white_solid.png" alt="GASD Icon">
            </div>
            <div class="header-text">
                <h1>Spec-Driven Development</h1>
                <p class="series-meta">Part 2 of 6</p>
            </div>
        </header>

        <section class="content">
            <blockquote>Specs aren't new. What's new is that AI agents need them to work reliably.</blockquote>

            <hr>

            <p>Specs predate the term "software engineer." From punched-card specifications in the 1940s to 10,000-page
                defense contract requirements in the 1980s, specifying what a system must do before building it is as
                old as the discipline itself.</p>
            <p>So why is Spec-Driven Development suddenly the most discussed topic in AI-assisted engineering?</p>
            <p>Because the audience has changed.</p>

            <h2>The Spec Graveyard — A Brief History</h2>
            <p><strong>Formal Methods (1970s–90s)</strong>: Z notation, VDM, TLA+. Mathematically rigorous, provably
                correct, and almost entirely unused in commercial software. Written for humans to verify, not machines
                to execute.</p>
            <p><strong>UML (1990s–2000s)</strong>: Visual design language, widely adopted, widely abandoned.
                Maintaining UML diagrams alongside living code cost more than the value they delivered.</p>
            <p><strong>OpenAPI (2010s)</strong>: Finally — spec-driven development that <em>stuck</em>. Specify your API
                before implementing it; generate client SDKs, server stubs, validation middleware, and docs from a
                single source. It worked because the spec drove tooling, not just humans.</p>
            <p><strong>The AI Era (now)</strong>: OpenAPI proved that a machine-readable spec can generate real
                artifacts — not just documentation, but executable code. LLMs have made this possible at the <em>entire
                    application design level</em>. The question is no longer "can we generate code from a spec?" The
                question is: "what kind of spec do you need for consistent, high-quality results?"</p>

            <h2>The Spec-First Shift</h2>
            <p>The core idea: <strong>the specification is the authoritative source of truth, above the code</strong>.
            </p>
            <p>In traditional workflows, specs drift immediately. Code diverges as requirements change and pragmatic
                decisions accumulate. Within months, the spec is archaeology.</p>
            <p>Spec-First flips this. The spec is not documentation written <em>after</em> decisions — it's the
                <em>medium in which decisions are made</em>. Code is derived from the spec, not the other way around.
            </p>
            <p>For AI-assisted development this is critical:</p>
            <ul>
                <li><strong>AI has no memory across sessions.</strong> Every new prompt starts from zero. A persistent
                    spec gives agents the context to make consistent decisions — session after session, agent after
                    agent.</li>
                <li><strong>Code reviews become design reviews.</strong> A spec change required for a code change makes
                    the design decision explicit, traceable, and reviewable — not buried in a diff.</li>
                <li><strong>Onboarding is instant.</strong> A new engineer (or new agent) reads the spec and understands
                    the architecture in minutes, not weeks.</li>
            </ul>

            <h2>The Industry Is Converging Here</h2>
            <p>This isn't academic. Three significant bets are being placed on spec-first AI development right now.</p>
            <p><strong>Amazon Kiro</strong> — an agentic IDE that builds SDD into the development loop itself.
                Requirements → structured user stories → technical design docs → task breakdown → implementation,
                triggered step by step. "Steering Files" lock in project conventions for every agent session.</p>
            <p><strong>Tessl</strong> — founded by Guy Podjarny (Snyk). Not an IDE — a Spec Registry, like npm but for
                AI agent knowledge. Over 10,000 pre-built usage specs for popular libraries stop agents from
                hallucinating APIs or version-mixing. Tessl's vision: eventually, comprehensive specs + tests make
                <em>code itself largely disposable</em> — just regenerate it.
            </p>
            <p><strong>Spec-kit frameworks</strong> — open-source DSLs for capturing design intent in machine-readable
                formats, layerable on existing workflows without switching IDEs or platforms.</p>
            <p>Three different approaches. One shared conclusion: <strong>the spec is the source of truth. The code is
                    the output.</strong></p>

            <h2>"Isn't This Just Documentation?" — Answered</h2>
            <p>But <strong>executable documentation doesn't rot the same way</strong>. When a spec drives code
                generation — when changing the spec regenerates different code — spec and implementation are coupled.
                They can't diverge silently. A team that modifies code without updating the spec creates a visible,
                explicit gap. The spec remains the authority.</p>

            <h2>The Design Bridge</h2>
            <pre><code>User Stories  →  Design Bridge (Spec)  →  Code
   "What"              "How"               "Runnable"</code></pre>

            <p>The Design Bridge sits between product requirements and implementation. It captures the architectural
                <em>how</em> — at a precision that eliminates interpretation variance when handed to an AI agent.
            </p>

            <h2>SDD Isn't New. The Urgency Is</h2>
            <ol>
                <li><strong>AI agents need machine-readable design context</strong> to produce consistent results.</li>
                <li><strong>Generation speed has outpaced review speed</strong> — the cost of specless AI coding is
                    higher than ever.</li>
                <li><strong>Multi-agent workflows are emerging</strong> — requiring shared, authoritative design
                    contracts that all agents can read.</li>
            </ol>

            <hr>
            <p><em>The spec is the prompt that never drifts.</em></p>
        </section>

        <div class="navigation-links">
            <a href="part-1-vibe-coding-vs-rigorous-engineering.html">← Previous: Part 1</a>
            <a href="part-3-gasd-design-language.html">Next: Part 3 — GASD: A Design Language →</a>
        </div>
    </main>
</body>

</html>