<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part 4: From User Story to Working Code - GASD</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500&family=Outfit:wght@600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="../../style.css">
</head>

<body>
    <main>
        <nav class="breadcrumb">
            <a href="../../index.html">Home</a> <span>/</span> <a href="Intro.html">Stop Vibe Coding</a> <span>/</span>
            <span>Part 4</span>
        </nav>

        <header>
            <div class="logo-container">
                <img src="../../logo_files/gasd_icon_white_solid.png" alt="GASD Icon">
            </div>
            <div class="header-text">
                <h1>From User Story to Working Code — A GASD Walkthrough</h1>
                <p class="series-meta">Part 4 of 6 · ⭐ Full Walkthrough</p>
            </div>
        </header>

        <section class="content">
            <blockquote>One login feature. No ambiguity. No drift. Here's the full run.</blockquote>
            <hr>
            <p>This is where theory meets practice. We take one user story through the complete GASD lifecycle: product
                requirement → design spec → human review checkpoint → AI-generated code → AI-generated tests. Every
                decision traceable. Every test inevitable.</p>

            <h2>Step 1 — The User Story</h2>
            <p>This comes from the product team. GASD doesn't replace it — it sits downstream of it.</p>
            <pre><code>US-042: As a registered user, I want to log in with my email and password
so that I can access my account dashboard.

Acceptance Criteria:
  AC-1: Valid credentials return a session token valid for 1 hour
  AC-2: Invalid email or password returns a 401 Unauthorized error
  AC-3: An account is locked after 5 consecutive failed login attempts
  AC-4: A locked account returns a 403 Forbidden error</code></pre>
            <p>Notice what it <em>doesn't</em> say: JWT vs. opaque tokens, bcrypt vs. argon2. Those are engineering
                decisions. This is exactly where unguided AI goes wrong — every implicit decision gets made differently
                every session.</p>

            <h2>Step 2 — The GASD Spec</h2>
            <p>The architect authors the spec — closing every door the user story left open.</p>
            <pre><code>CONTEXT: "REST API backend"
TARGET: "Python / FastAPI"
TRACE: "US-042", "AC-1", "AC-2", "AC-3", "AC-4"

// ── Locked Design Decisions ───────────────────────────────────────
DECISION "Token Format":
    CHOSEN: "JWT (HS256, 1-hour expiry)"
    RATIONALE: "Stateless — no session store required for MVP."

DECISION "Password Hashing":
    CHOSEN: "bcrypt (cost=12)"

// ── Type Contracts ─────────────────────────────────────────────────
TYPE LoginRequest:
    email:    String @format("email") @max_length(255)
    password: String @min_length(8) @sensitive

// ── Behavioral Flow ────────────────────────────────────────────────
FLOW login(req: LoginRequest) -> SessionToken:
    @error_strategy("Exception-based")
    1. VALIDATE req
    2. ACHIEVE "Fetch user" via UserRepository
        ON_ERROR: THROW UnauthorizedException("Invalid credentials")
    3. ENSURE password_matches(req.password, user.password_hash)
        OTHERWISE THROW UnauthorizedException("Invalid credentials")
    4. ENSURE user.failed_attempts < 5
        OTHERWISE THROW ForbiddenException("Account locked")
    5. ACHIEVE "Reset failed_attempts to 0" via UserRepository
    6. CREATE SessionToken
    7. RETURN SessionToken

// ── Global Rules ───────────────────────────────────────────────────
CONSTRAINT: "All authentication errors MUST use the same error message"
INVARIANT:  "A locked account MUST NOT be unlocked automatically"</code></pre>

            <h2>Step 3 — The Human Review Checkpoint</h2>
            <p>Before handing to an agent, a colleague spots a gap: <em>"When a user successfully logs in, do we reset
                    their failed_attempts counter?"</em></p>
            <p>In GASD, this becomes a formal block:</p>
            <pre><code>QUESTION: "Should a successful login reset failed_attempts to 0?"
    BLOCKING: true
    CONTEXT: AuthService.login
    RAISED_BY: "Lead Architect"</code></pre>
            <p>The team decides: <strong>yes, reset on success — non-locked accounts only.</strong> Step 5 of the FLOW
                reflects it. Decision recorded, dated, traceable.</p>

            <h2>Step 4 — AI Generates the Code</h2>
            <pre><code># auth_service.py — Generated from GASD spec (TRACE: US-042)

class AuthService:
    def login(self, req: LoginRequest) -> SessionToken:
        # Step 2: Fetch user — same message on failure (anti-enumeration CONSTRAINT)
        user = self._repo.find_by_email(req.email)
        if not user:
            raise HTTPException(status_code=401, detail="Invalid credentials")

        # Step 3: Verify password — DECISION: bcrypt (cost=12)
        if not bcrypt.checkpw(req.password.encode(), user.password_hash.encode()):
            self._repo.increment_failed_attempts(user.id)
            raise HTTPException(status_code=401, detail="Invalid credentials")

        # Step 4: Check account lock — INVARIANT enforced
        if user.failed_attempts >= 5:
            raise HTTPException(status_code=403, detail="Account locked.")

        # Step 5: Reset counter on success (QUESTION resolved: yes)
        self._repo.reset_failed_attempts(user.id)

        # Step 6: Generate JWT — DECISION: HS256, 1-hour expiry
        ...</code></pre>

            <h2>Step 5 — AI Generates the Tests</h2>
            <p>From the same spec, the agent generates the test suite mapping directly to acceptance criteria.</p>
            <pre><code># AC-2: Invalid email returns 401 with generic message
def test_login_unknown_email_returns_401(service, mock_repo):
    mock_repo.find_by_email.return_value = None
    with pytest.raises(HTTPException) as exc:
        service.login(LoginRequest(email="x@y.com", password="..."))
    assert exc.value.status_code == 401
    assert exc.value.detail == "Invalid credentials"  # CONSTRAINT verified</code></pre>
            <p>The developer never wrote "test anti-enumeration." The GASD <code>CONSTRAINT</code> made that test
                <strong>inevitable</strong>.
            </p>

            <h2>Conclusion: What Just Happened</h2>
            <table>
                <thead>
                    <tr>
                        <th>Artifact</th>
                        <th>Source</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>auth_service.py</code></td>
                        <td>Generated from GASD spec</td>
                    </tr>
                    <tr>
                        <td><code>test_auth_service.py</code></td>
                        <td>Generated from same GASD spec</td>
                    </tr>
                    <tr>
                        <td>Anti-enumeration constraint</td>
                        <td>Added by architect — not in user story</td>
                    </tr>
                    <tr>
                        <td>Counter reset behavior</td>
                        <td>Resolved via <code>QUESTION</code> block</td>
                    </tr>
                </tbody>
            </table>
            <hr>
            <p><em>The spec makes right behavior inevitable. The AI fills in the blanks — it doesn't make the
                    decisions.</em></p>
        </section>

        <div class="navigation-links">
            <a href="part-3-gasd-design-language.html">← Previous: Part 3</a>
            <a href="part-5-human-ai-collaboration.html">Next: Part 5 — Human + AI: The New Collaboration Model →</a>
        </div>
    </main>
</body>

</html>